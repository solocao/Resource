<?xml version="1.0" encoding="UTF-8"?>
<!-- 映射文件的编写步骤：
1、在实体类所在的包下创建一个名称和实体类名称一致的xml文件
	例如：CstCustomer.hbm.xml
2、导入约束
	约束在hibernate核心jar中
	hibernate-mapping-3.0.dtd
-->
<!DOCTYPE hibernate-mapping PUBLIC 
    "-//Hibernate/Hibernate Mapping DTD 3.0//EN"
    "http://www.hibernate.org/dtd/hibernate-mapping-3.0.dtd">
<hibernate-mapping package="cn.itcast.domain">
	<!-- class：
			作用：建立实体类和表的对应关系 
			属性：
			  name:指定实体类的名称
			  table：指定的是表的名称
	-->
	<class name="CstCustomer" table="cst_customer">
		<!-- 建立表中每列和实体类中每个字段的对应关系 
			此处之后再出现的name，都是指实体类中对应字段的get/set方法后面的部分。并且把首字母改小写。
			private Long custId;
			public Long getCustId() {
				return custId;
			}
			public void setCustId(Long custId) {
				this.custId = custId;
			}
		-->
		<!-- id标签：
				作用：用于描述主键
				属性：
				  name:指定实体类中主键字段名称
				  column：指定表中主键名称
			 	
		 -->
		<id name="custId" column="cust_id">
			<!--使用 generator标签来描述主键的生成方式
				 native指的是使用本地数据库自动增长的能力（是根据数据支持哪种自增长方式来选择的）
			-->
			<generator class="native"></generator>
		</id>
		<!-- property标签：
					作用：用于描述其他字段的对应关系。
					属性：
					  name：都是对应实体类中字段的名称
					  column：对应表中列的名称
		-->
		<property name="custName" column="cust_name"></property>
		<property name="custSource" column="cust_source"></property>
		<property name="custIndustry" column="cust_industry"></property>
		<property name="custLevel" column="cust_level"></property>
		<property name="custAddress" column="cust_address"></property>
		<property name="custPhone" column="cust_phone"></property>
		
		<!-- 一对多关系映射 
			涉及的元素：
				set元素：就是用于映射集合属性
			涉及的属性：
				name：指定集合属性的get/set方法后面的部分。
				table：指定的是集合属性中元素所对应的表。
				inverse：是否放弃维护的权利。取值为true放弃/false不放弃。默认不放弃
				  		它解决的问题就是多次跟数据库交互的问题。
				  		它应该只出现在set元素上。
			涉及set的子元素：
				key：就是用于映射外键字段的。
				one-to-many：指的是当前实体和集合元素之间的关系。
							CstCustomer 和 Set<CstLinkMan>中的CstLinkMan之间的关系是一对多
			涉及子元素中的属性：
				key元素的column属性：用于指定从表中外键字段的名称
				one-to-many元素的class属性：指定集合元素所对应的实体类
		-->
		<set name="linkmans" table="cst_linkman">
			<key column="lkm_cust_id"></key>
			<one-to-many class="CstLinkMan"/>
		</set>
	</class>
	<!-- 配置命名查询的HQL语句 -->
	<query name="findCustomerByCondition">
		<![CDATA[
			from CstCustomer where  custSource = :custSource and custName like :custName
		]]>
	</query>
</hibernate-mapping>